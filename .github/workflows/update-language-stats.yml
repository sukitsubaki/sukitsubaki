name: Update Language Stats

on:
  schedule:
    - cron: '0 * * * *'  # Runs every hour
  workflow_dispatch:  # Allows manual triggering

permissions:
  contents: write

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '16'
          
      - name: Create script file
        run: |
          cat > generate-stats.js << 'EOF'
          const fs = require("fs");
          const path = require("path");
          const stats = JSON.parse(fs.readFileSync("stats.json", "utf8"));
          let readme = fs.readFileSync("README.md", "utf8");
          
          // Get configuration from environment variables
          const showOthers = process.env.SHOW_OTHERS === "true";
          const topCount = parseInt(process.env.TOP_LANGUAGES) || 6;
          const svgFilename = "language-stats.svg";
          const svgDir = path.dirname(process.env.SVG_FILENAME) || "api/language-stats";
          
          // Use same weights as github-readme-stats
          const sizeWeight = 0.5;
          const countWeight = 0.5;
          
          // Language colors (GitHub colors)
          const languageColors = {
            "PHP": { bg: "#8993be", text: "#ffffff" },
            "JavaScript": { bg: "#f1e05a", text: "#000000" },
            "TypeScript": { bg: "#3178c6", text: "#ffffff" },
            "HTML": { bg: "#e34c26", text: "#ffffff" },
            "CSS": { bg: "#563d7c", text: "#ffffff" },
            "Python": { bg: "#3572A5", text: "#ffffff" },
            "Java": { bg: "#b07219", text: "#ffffff" },
            "Ruby": { bg: "#701516", text: "#ffffff" },
            "Go": { bg: "#00ADD8", text: "#ffffff" },
            "Swift": { bg: "#ffac45", text: "#000000" },
            "C": { bg: "#555555", text: "#ffffff" },
            "C++": { bg: "#f34b7d", text: "#ffffff" },
            "C#": { bg: "#178600", text: "#ffffff" },
            "Shell": { bg: "#89e051", text: "#000000" },
            "Rust": { bg: "#dea584", text: "#000000" },
            "Other": { bg: "#ededed", text: "#000000" }
          };
          
          // Calculate language percentages using the github-readme-stats formula
          
          // Start by extracting the same data structure from our API result
          const languages = {};
          
          // Create a map of repos to track which languages appear in which repos
          const repoLanguages = {};
          
          // Parse original stats data
          Object.entries(stats.languages).forEach(([lang, data]) => {
            // Initialize language entry if not exists
            if (!languages[lang]) {
              languages[lang] = {
                name: lang,
                color: languageColors[lang]?.bg || "#808080",
                textColor: languageColors[lang]?.text || "#000000",
                size: 0,
                count: 0,
                score: 0
              };
            }
            
            // Add byte count
            languages[lang].size = data.bytes;
          });
          
          // Now we need to count repos that contain each language
          // Since our API doesn't directly provide this, we need to estimate
          // or use the data we have from our private repos
          
          // For this demo, we'll assume each language appears in at least one repo
          // This is a starting approximation
          Object.keys(languages).forEach(lang => {
            languages[lang].count = 1;
          });
          
          // Apply the github-readme-stats formula for weighting
          Object.keys(languages).forEach(lang => {
            // Their formula: Score = Size^(size_weight) * Count^(count_weight)
            languages[lang].score = 
              Math.pow(languages[lang].size, sizeWeight) * 
              Math.pow(languages[lang].count, countWeight);
          });
          
          // Sort languages by score
          const sortedLanguages = Object.values(languages)
            .sort((a, b) => b.score - a.score)
            .slice(0, topCount);
          
          // Calculate total score for percentage calculation
          const totalScore = sortedLanguages.reduce((sum, lang) => sum + lang.score, 0);
          
          // Calculate percentages
          sortedLanguages.forEach(lang => {
            lang.percentage = (lang.score / totalScore) * 100;
          });
          
          // Function to format percentage
          const formatPercentage = (pct) => pct.toFixed(2) + "%";
          
          // Create SVG visualization
          const svgWidth = 900;         // Width in pixels
          const barHeight = 20;         // Bar height 20px as requested
          const percentFontSize = 12;   // Font size 12px as requested
          const langFontSize = 10;      // Font size for language names (below bar)
          const textSpacing = 6;        // Space between bar and language text
          const bottomPadding = 4;      // Added padding at the bottom
          
          // Total SVG height with increased spacing to prevent text cutoff
          const svgHeight = barHeight + textSpacing + langFontSize + bottomPadding;
          
          const fontFamily = "'Noto Sans', Helvetica, Arial, sans-serif";  // Font family with fallbacks
          const langTextColor = "#1f2328"; // Language text color
          
          // Calculate cumulative width for each language
          let totalWidth = 0;
          sortedLanguages.forEach(lang => {
            lang.percentage_width = lang.percentage / 100;
            lang.width = Math.floor(lang.percentage_width * svgWidth);
            lang.x = totalWidth;
            totalWidth += lang.width;
          });
          
          // Adjust to ensure the total width equals svgWidth exactly
          if (totalWidth !== svgWidth) {
            const diff = svgWidth - totalWidth;
            // Add the difference to the widest bar to minimize visual impact
            const widestLang = [...sortedLanguages].sort((a, b) => b.width - a.width)[0];
            widestLang.width += diff;
          }
          
          // Create SVG with explicit viewBox and preserveAspectRatio
          let svg = `<svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">\n`;
          
          // Add border-radius of 6px through rect with border-radius and clipping
          svg += `  <defs>\n`;
          svg += `    <clipPath id="roundedBar">\n`;
          svg += `      <rect x="0" y="0" width="${svgWidth}" height="${barHeight}" rx="6" ry="6" />\n`;
          svg += `    </clipPath>\n`;
          svg += `  </defs>\n`;
          
          // Add a group with the clipping path
          svg += `  <g clip-path="url(#roundedBar)">\n`;
          
          // Add bar segments
          sortedLanguages.forEach((lang, index) => {
            const x = lang.x;
            svg += `    <rect x="${x}" y="0" width="${lang.width}" height="${barHeight}" fill="${lang.color}" />\n`;
          });
          
          svg += `  </g>\n`;
          
          // Add percentage text inside each bar segment
          sortedLanguages.forEach(lang => {
            const textX = lang.x + (lang.width / 2);
            const percentY = barHeight / 2; // Centered vertically in the bar
            
            // Only add percentage text if there's enough space (bar width > 40px)
            if (lang.width > 40) {
              svg += `  <text x="${textX}" y="${percentY}" text-anchor="middle" dominant-baseline="middle" font-family="${fontFamily}" font-size="${percentFontSize}" font-weight="bold" fill="${lang.textColor}">${formatPercentage(lang.percentage)}</text>\n`;
            }
          });
          
          // Add language names below each bar segment
          sortedLanguages.forEach(lang => {
            const textX = lang.x + (lang.width / 2);
            const langY = barHeight + textSpacing + (langFontSize / 2); // Adjusted position
            
            // Only add language name if there's enough space (bar width > 30px)
            if (lang.width > 30) {
              svg += `  <text x="${textX}" y="${langY}" text-anchor="middle" dominant-baseline="middle" font-family="${fontFamily}" font-size="${langFontSize}" fill="${langTextColor}">${lang.name}</text>\n`;
            }
          });
          
          svg += "</svg>";
          
          // Generate a unique filename to prevent caching issues
          const timestamp = new Date().getTime();
          const uniqueSvgFilename = svgFilename.replace('.svg', `-${timestamp}.svg`);
          
          // Make sure the directory exists
          if (!fs.existsSync(svgDir)) {
            fs.mkdirSync(svgDir, { recursive: true });
          }
          
          // Save SVG to file with timestamp in name
          fs.writeFileSync(path.join(svgDir, uniqueSvgFilename), svg);
          
          // Clean up old SVG files (keep only the latest)
          const files = fs.readdirSync(svgDir);
          files.forEach(file => {
            if (file.startsWith('language-stats-') && file.endsWith('.svg') && file !== uniqueSvgFilename) {
              try {
                fs.unlinkSync(path.join(svgDir, file));
                console.log(`Deleted old file: ${file}`);
              } catch (err) {
                console.error(`Error deleting file ${file}:`, err);
              }
            }
          });
          
          // Create markdown for README with HTML to ensure full width
          let langSection = `<img src="${svgDir}/${uniqueSvgFilename}" width="100%" alt="My Programming Languages">`;
          
          // Replace existing section or append to the end
          const startMarker = "<!-- START_LANGUAGE_STATS -->";
          const endMarker = "<!-- END_LANGUAGE_STATS -->";
          
          if (readme.includes(startMarker) && readme.includes(endMarker)) {
            // Replace existing section
            const regex = new RegExp(`${startMarker}[\\s\\S]*?${endMarker}`, "g");
            readme = replace(regex, `${startMarker}\n${langSection}\n${endMarker}`);
          } else {
            // Append at the end
            readme += `\n\n${startMarker}\n${langSection}\n${endMarker}`;
          }
          
          fs.writeFileSync("README.md", readme);
          EOF
      
      - name: Generate Language Stats SVG and Update README
        run: |
          # Configuration
          export SHOW_OTHERS="false"  # Set to "true" to show "Other" category, "false" to rescale top 6 to 100%
          export TOP_LANGUAGES=6      # Show top 6 languages
          export SVG_FILENAME="api/language-stats/language-stats.svg"  # Name of the SVG file to generate
          
          # Fetch the API and save results
          curl -s "https://sukitsubaki.vercel.app/language-stats" > stats.json
          
          # Run the Node.js script from file instead of inline
          node generate-stats.js
          
      - name: Commit changes
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"
          git add api/language-stats/language-stats-*.svg README.md
          git diff --quiet && git diff --staged --quiet || git commit -m "Update language stats in README"
          git push
