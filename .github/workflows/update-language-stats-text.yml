const fs = require("fs");
const path = require("path");
const stats = JSON.parse(fs.readFileSync("stats.json", "utf8"));
let readme = fs.readFileSync("README.md", "utf8");

// Configuration from environment variables
const topCount = parseInt(process.env.TOP_LANGUAGES) || 6;

// Weights for calculation
const sizeWeight = 0.5;
const countWeight = 0.5;

// Initialize language data structure
const languages = {};

// Track totals
let totalBytes = 0;

// Parse stats data
Object.entries(stats.languages).forEach(([lang, data]) => {
  // Initialize language entry
  if (!languages[lang]) {
    languages[lang] = {
      name: lang,
      size: 0,
      count: 0,
      score: 0
    };
  }
  
  // Add byte count
  languages[lang].size = data.bytes;
  languages[lang].count = 1; // Minimum count for each language
  
  // Track totals
  totalBytes += data.bytes;
});

// Calculate weighted scores
Object.keys(languages).forEach(lang => {
  languages[lang].score = 
    Math.pow(languages[lang].size, sizeWeight) * 
    Math.pow(languages[lang].count, countWeight);
});

// Sort languages by score and get top languages
const sortedLanguages = Object.values(languages)
  .sort((a, b) => b.score - a.score);
  
const topLanguages = sortedLanguages.slice(0, topCount);

// Calculate total score for percentage calculation
const totalScore = topLanguages.reduce((sum, lang) => sum + lang.score, 0);

// Calculate percentages
topLanguages.forEach(lang => {
  lang.percentage = (lang.score / totalScore) * 100;
});

// Function to create progress bar
const createProgressBar = (percentage) => {
  const barLength = 40; // Total length of progress bar
  const filledLength = Math.round((percentage / 100) * barLength);
  const emptyLength = barLength - filledLength;
  
  // Using black blocks and dotted blocks as seen in the screenshot
  return '█'.repeat(filledLength) + '░'.repeat(emptyLength);
};

// Format file size in a human-readable way with separated number and unit
const formatBytes = (bytes) => {
  if (bytes === 0) return ['0', 'B'];
  
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  const value = parseFloat((bytes / Math.pow(k, i)).toFixed(2));
  return [value.toString(), sizes[i]];
};

// Generate text output in Python format
let statsText = "language_stats = {\n";

// Width settings for formatting
const percentWidth = 8;

// Get max width for size values and units for right alignment
let maxSizeValueWidth = 0;
let maxSizeUnitWidth = 0;

// Find the length of the longest language name
const maxNameLength = topLanguages.reduce((max, lang) => 
  Math.max(max, lang.name.length), 0);

// Calculate widths for alignment
topLanguages.forEach(lang => {
  const [sizeValue, sizeUnit] = formatBytes(lang.size);
  maxSizeValueWidth = Math.max(maxSizeValueWidth, sizeValue.length);
  maxSizeUnitWidth = Math.max(maxSizeUnitWidth, sizeUnit.length);
});

// Add language stats in Python dictionary format
topLanguages.forEach((lang, index) => {
  // Format language name - align all colons to the same position
  const nameField = `    "${lang.name}"`;
  // Calculate spaces needed to align colons
  const colonPosition = maxNameLength + 8; // "    "" + name + "" + spaces
  const spacesToColon = ' '.repeat(colonPosition - nameField.length);
  
  // Progress bar
  const progressBar = createProgressBar(lang.percentage);
  
  // Format percentage (right-aligned with space before %)
  const percentField = lang.percentage.toFixed(2).padStart(percentWidth - 1, ' ') + " %";
  
  // Format size with right-aligned number and left-aligned unit
  const [sizeValue, sizeUnit] = formatBytes(lang.size);
  const sizeValueField = sizeValue.padStart(maxSizeValueWidth, ' ');
  
  // Build the line with Python syntax
  statsText += `${nameField}${spacesToColon}: "${progressBar}", # ${percentField} | ${sizeValueField} ${sizeUnit}`;
  
  // Add comma if not the last item
  if (index < topLanguages.length - 1) {
    statsText += "\n";
  }
});

// Close the Python dictionary
statsText += "\n}";

// Create markdown for README with Python code block
let langSection = "```python\n" + statsText + "\n```";

// Update README content
const startMarker = "<!-- START_LANGUAGE_STATS_TEXT -->";
const endMarker = "<!-- END_LANGUAGE_STATS_TEXT -->";

if (readme.includes(startMarker) && readme.includes(endMarker)) {
  // Replace existing section
  const regex = new RegExp(`${startMarker}[\\s\\S]*?${endMarker}`, "g");
  readme = readme.replace(regex, `${startMarker}\n${langSection}\n${endMarker}`);
} else {
  // Append at the end
  readme += `\n\n${startMarker}\n${langSection}\n${endMarker}`;
}

fs.writeFileSync("README.md", readme);
